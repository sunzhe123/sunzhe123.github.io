(function(e){function t(t){for(var i,r,l=t[0],o=t[1],c=t[2],h=0,u=[];h<l.length;h++)r=l[h],Object.prototype.hasOwnProperty.call(a,r)&&a[r]&&u.push(a[r][0]),a[r]=0;for(i in o)Object.prototype.hasOwnProperty.call(o,i)&&(e[i]=o[i]);d&&d(t);while(u.length)u.shift()();return s.push.apply(s,c||[]),n()}function n(){for(var e,t=0;t<s.length;t++){for(var n=s[t],i=!0,r=1;r<n.length;r++){var l=n[r];0!==a[l]&&(i=!1)}i&&(s.splice(t--,1),e=o(o.s=n[0]))}return e}var i={},r={app:0},a={app:0},s=[];function l(e){return o.p+"js/"+({about:"about",catalog:"catalog",detail:"detail",series:"series"}[e]||e)+".js"}function o(t){if(i[t])return i[t].exports;var n=i[t]={i:t,l:!1,exports:{}};return e[t].call(n.exports,n,n.exports,o),n.l=!0,n.exports}o.e=function(e){var t=[],n={detail:1,series:1};r[e]?t.push(r[e]):0!==r[e]&&n[e]&&t.push(r[e]=new Promise((function(t,n){for(var i="css/"+({about:"about",catalog:"catalog",detail:"detail",series:"series"}[e]||e)+".css",a=o.p+i,s=document.getElementsByTagName("link"),l=0;l<s.length;l++){var c=s[l],h=c.getAttribute("data-href")||c.getAttribute("href");if("stylesheet"===c.rel&&(h===i||h===a))return t()}var u=document.getElementsByTagName("style");for(l=0;l<u.length;l++){c=u[l],h=c.getAttribute("data-href");if(h===i||h===a)return t()}var d=document.createElement("link");d.rel="stylesheet",d.type="text/css",d.onload=t,d.onerror=function(t){var i=t&&t.target&&t.target.src||a,s=new Error("Loading CSS chunk "+e+" failed.\n("+i+")");s.code="CSS_CHUNK_LOAD_FAILED",s.request=i,delete r[e],d.parentNode.removeChild(d),n(s)},d.href=a;var m=document.getElementsByTagName("head")[0];m.appendChild(d)})).then((function(){r[e]=0})));var i=a[e];if(0!==i)if(i)t.push(i[2]);else{var s=new Promise((function(t,n){i=a[e]=[t,n]}));t.push(i[2]=s);var c,h=document.createElement("script");h.charset="utf-8",h.timeout=120,o.nc&&h.setAttribute("nonce",o.nc),h.src=l(e);var u=new Error;c=function(t){h.onerror=h.onload=null,clearTimeout(d);var n=a[e];if(0!==n){if(n){var i=t&&("load"===t.type?"missing":t.type),r=t&&t.target&&t.target.src;u.message="Loading chunk "+e+" failed.\n("+i+": "+r+")",u.name="ChunkLoadError",u.type=i,u.request=r,n[1](u)}a[e]=void 0}};var d=setTimeout((function(){c({type:"timeout",target:h})}),12e4);h.onerror=h.onload=c,document.head.appendChild(h)}return Promise.all(t)},o.m=e,o.c=i,o.d=function(e,t,n){o.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},o.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(e,t){if(1&t&&(e=o(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(o.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)o.d(n,i,function(t){return e[t]}.bind(null,i));return n},o.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return o.d(t,"a",t),t},o.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},o.p="../",o.oe=function(e){throw console.error(e),e};var c=window["webpackJsonp"]=window["webpackJsonp"]||[],h=c.push.bind(c);c.push=t,c=c.slice();for(var u=0;u<c.length;u++)t(c[u]);var d=h;s.push([0,"chunk-vendors"]),n()})({0:function(e,t,n){e.exports=n("56d7")},"1b0f":function(e,t,n){e.exports=n.p+"img/d3.jpg"},2116:function(e,t,n){e.exports=n.p+"img/cdn.jpg"},"505b":function(e,t,n){},"56d7":function(e,t,n){"use strict";n.r(t);n("cadf"),n("551c"),n("f751"),n("097d");var i=n("2b0e"),r=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{attrs:{id:"app"}},[n("NavBar",{attrs:{currentPath:e.currentPath}}),n("el-card",{staticClass:"box-card"},[n("transition",{attrs:{name:e.transationName}},[n("router-view")],1)],1)],1)},a=[],s=(n("7f7f"),function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"nav-bar-wrapper"},[n("PortraitView",{staticClass:"portrait-view-style"}),n("div",{staticClass:"nav-bar-list"},[n("router-link",{staticClass:"nav-bar-item",class:e._f("getClassName")("/home/index.html",e.currentPath),attrs:{to:"/home/index.html"}},[e._v("文章")]),n("router-link",{staticClass:"nav-bar-item",class:e._f("getClassName")("/series/index.html",e.currentPath),attrs:{to:"/series/index.html"}},[e._v("系列")]),n("router-link",{staticClass:"nav-bar-item",class:e._f("getClassName")("/about/index.html",e.currentPath),attrs:{to:"/about/index.html"}},[e._v("关于")])],1)],1)}),l=[],o=function(){var e=this,t=e.$createElement;e._self._c;return e._m(0)},c=[function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("div",{staticClass:"portrait-view"},[i("div",{staticClass:"user-portrait"},[i("img",{attrs:{src:n("b0e3")}})]),i("div",{staticClass:"user-id"},[e._v("大哲子")])])}],h={props:{}},u=h,d=(n("764e"),n("2877")),m=Object(d["a"])(u,o,c,!1,null,"0c72d1f0",null),p=m.exports,f={props:{currentPath:{type:String}},filters:{getClassName:function(e,t){return e==t?"nav-bar-item-active":""}},components:{PortraitView:p},watch:{}},g=f,b=(n("6252"),Object(d["a"])(g,s,l,!1,null,"a239da48",null)),v=b.exports,x={data:function(){return{transationName:"slide-fade-right",routeStack:[],currentPath:""}},watch:{$route:{handler:function(e,t){var n=t||{};this.currentPath=e.path;var i=this.routeStack.length,r=i?this.routeStack[i-1]:{};i&&n&&r.to==n.name&&r.from==e.name?(this.routeStack.pop(),this.transationName="slide-fade-left"):(this.routeStack.push({to:e.name,from:n.name}),this.transationName="slide-fade-right")},immediate:!0}},components:{NavBar:v},methods:{}},y=x,N=(n("5c0b"),Object(d["a"])(y,r,a,!1,null,null,null)),w=N.exports,j=n("8c4f"),T=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"home-wrapper"},e._l(e.articleList,(function(t){return n("el-card",{key:t.id,staticClass:"article-card"},[n("div",{staticClass:"article-img",on:{click:function(n){return e.handleDetail(t.id)}}},[n("img",{attrs:{src:t.articleImg}})]),n("div",{staticClass:"article-title"},[e._v(e._s(t.articleTitle))])])})),1)},I=[],C=(n("1c01"),n("58b2"),n("8e6e"),n("f3e2"),n("d25f"),n("ac6a"),n("456d"),n("bd86")),P=n("2f62");function k(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function S(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?k(Object(n),!0).forEach((function(t){Object(C["a"])(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):k(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var O={name:"home",components:{},computed:S({},Object(P["b"])(["articleList"])),data:function(){return{msg:"asdasdas",showView:!1}},created:function(){},mounted:function(){},methods:{handleDetail:function(e){this.$router.push({path:"/detail/index.html",query:{detailId:e,type:"article"}})}}},_=O,L=(n("edc4"),Object(d["a"])(_,T,I,!1,null,"075f652a",null)),W=L.exports,E=(n("386d"),n("4917"),n("3b2b"),n("df7c")),B=n.n(E);function D(){console.log("--hrefStr:",e),console.log("--path.dirname(hrefStr):",B.a.dirname(e));var e=window.location.pathname,t="/";return/\/$/.test(e)&&(e+="index.html"),console.log("--hrefStr:",e),console.log("--path.dirname(hrefStr):",B.a.dirname(e)),t=B.a.dirname(B.a.dirname(e)),t}i["default"].use(j["a"]);var $=new j["a"]({mode:"history",base:D(),routes:[{path:"/",redirect:"/home/index.html"},{path:"/home/index.html",name:"home/index.html",component:W},{path:"/series/index.html",name:"series/index.html",component:function(){return n.e("series").then(n.bind(null,"538b"))}},{path:"/catalog/index.html",name:"catalog/index.html",component:function(){return n.e("catalog").then(n.bind(null,"f7b4"))}},{path:"/about/index.html",name:"about/index.html",component:function(){return n.e("about").then(n.bind(null,"754b"))}},{path:"/detail/index.html",name:"detail/index.html",component:function(){return n.e("detail").then(n.bind(null,"1000"))}}]});i["default"].use(P["a"]);var A=new P["a"].Store({state:{articleList:[{id:"article-001",articleTitle:"移动端弹窗滑动穿透",articleImg:n("5722")},{id:"article-002",articleTitle:"发布生产 解决CDN缓存导致异常",articleImg:n("2116")},{id:"article-003",articleTitle:"前端性能优化总结",articleImg:n("75c1")},{id:"article-004",articleTitle:"Jquery面向对象写法",articleImg:n("f638")},{id:"article-005",articleTitle:"history模式404解决方案",articleImg:n("a8f0")},{id:"article-006",articleTitle:"vue-cli3 history模式404解决&发布CDN缓存解决",articleImg:n("a8f0")},{id:"article-007",articleTitle:"闭包的应用",articleImg:n("7402")},{id:"article-008",articleTitle:"骨架屏的使用",articleImg:n("af95")},{id:"article-009",articleTitle:"滑动尺效果的实现",articleImg:n("e0fc")},{id:"article-010",articleTitle:"移动端解决圆角边框一像素问题",articleImg:n("e0fc")},{id:"article-011",articleTitle:"npm-check -u",articleImg:n("e0fc")},{id:"article-012",articleTitle:"vue项目跳转外链回退不刷新解决",articleImg:n("e0fc")},{id:"article-013",articleTitle:"android手机锁屏倒计时停止问题",articleImg:n("e0fc")},{id:"article-014",articleTitle:"前端断点续传",articleImg:n("e0fc")},{id:"article-015",articleTitle:"LottieJS动画",articleImg:n("e0fc")},{id:"article-016",articleTitle:"前端启动本地服务进行调试",articleImg:n("e0fc")},{id:"article-017",articleTitle:"调试本地代码:配置nginx使路径与生产环境一致",articleImg:n("e0fc")},{id:"article-018",articleTitle:"css modules",articleImg:n("e0fc")},{id:"article-019",articleTitle:"回退白屏",articleImg:n("e0fc")},{id:"article-020",articleTitle:"React setState的回调处理",articleImg:n("e0fc")},{id:"article-021",articleTitle:"Vue路由跳转的动画过渡",articleImg:n("e0fc")},{id:"article-022",articleTitle:"console打印增加颜色",articleImg:n("e0fc")}],articleDetailList:[{detailId:"article-001",detailTitle:"移动端弹窗滑动穿透",detailText:"\n                <h1>问题描述</h1>\n                <h2>\n                    当我们日常开发中, 页面中展示弹窗的交互必不可少, 一般都是加一个蒙层, 居中画一个弹窗, 在PC端没有任务问题, \n                    但是我们会发现, 如果在做移动端的时候, 在弹窗上滑动, 背景页面也会跟随滑动, 或者有时候弹窗里有滚动元素, 页面也可滚动,\n                    手指滑动有时弹窗里滑动, 有的时候背景页面滑动, 这就是发生了滑动穿透\n                </h2>\n                <h2>上述所说的穿透现象, 非常影响交互体验, 所以要想办法解决背景滑动的情况</h2>\n\n                <h1>方案一</h1>\n                <h2>\n                    当在所需的弹窗弹出时, 对html标签增加fixed定位, top:0 left0 宽高100% overflow:hidden, 这样相当于给htm固定住, 禁止外层存在滚动条, \n                    然后当关闭弹窗的时候, 把该定位样式去掉, 但是当外层有滚区域的话, 关闭弹窗后会发现页面回到了顶部, 这就需要在展示弹窗前记录滚动高度, 然后关闭之后\n                    滚回到之前的位置\n                </h2>\n\n                <h1>方案二</h1>\n                <h2>\n                    第二种方案就是阻止touchmove默认事件, 让滑动失去效果, 不让页面滚动, 当然, 这样就会一荣俱荣一损俱损了, 弹窗内如果有可滚动元素, \n                    也会不可滑动了, 所以这时候需要引入iscroll, 将需要滚动的内容包裹到iscroll里, 这样就完美解决了, 需要注意的是当关闭弹窗时要把\n                    对touchmove事件的阻止删除掉, 避免影响恢复到正常页面的滑动\n                </h2>\n               "},{detailId:"article-002",detailTitle:"CDN缓存导致的",detailText:"\n                <h1>问题描述: </h1>\n                <h2>\n                    每当迭代发布生产时, 都会遇到一个比较头疼的问题, 就是CDN缓存. \n                    html生效了, 但是引用的js css静态资源有的生效有的还是缓存的, 就会导致页面出现异常.\n                    比如使用vue打包出来的项目, 目录里一般是包含: html css js img这些资源, \n                    如果两个\n                </h2>\n                <h1>解决方案</h1>\n                <h2>\n                    每次打包的时候, 生成带有hash的文件名, 这种也是最常用的方式, 打包好后扔到服务器上, 原来的文件不要动, \n                    每次发布的版本都会在上面保留, 这样当html在加载资源时候, 如果html缓存没有更新, 就会加载原来hash的资源文件, \n                    请求时正常的, 如果html缓存更新了, 会加载新发布的hash的资源文件, 这个不会有缓存问题, 也能正常加载, 可以解决问题. \n                    但是有一个弊病就是, 当迭代的多了, 文件较多, 服务器上分不清哪个是上次的 上上次的 ..., 当分件过多想删除的时, \n                    需要一个一个的去识别, 并且还要css js都能匹配删除, 如果不小心删除错了, css和js对不上, 那就出问题了\n                </h2>\n\n                <h1>解决方案升级版</h1>\n                <h2>\n                    每次打包的时候, 把所有的静态资源不要放到dist的根路径, 每次都创建一个带唯一版本号的文件夹, \n                    然后把资源打包到这个文件夹下, 这样就类似于第一种解决办法一样, 不管是加载新的还是老的资源其实是都在的, \n                    而且能够保证css js是配套加载的, 当文件过多想删除的时候, 可以按照文件夹去删除, 也不会出现方案1的弊病问题.\n                    然后为了保证index.html里引用的资源都是同一个版本发布的, 那么资源文件的入口就应该只有一个: 不带版本号的app.js,\n                    其他资源都放到版本文件夹里, 有缓存的时候, index.html里的唯一入口js会加载老版本的一套资源, 缓存刷新了就会加载新的一套资源, \n                    能保证资源都为一套版本, 所以css文件也要打包到js里, 然后app.js和chunk-vendor.js 打成一个app.js, 这样文件可能会变得比较大,\n                    所以要注意组件都按照切片的形式进行加载, 如此这般, 就能保证index.html所引用的资源都为同一个版本的内容, 不会出现CDN缓存问题导致版本不一致出现花屏情况\n                </h2>\n                "},{detailId:"article-003",detailTitle:"前端性能优化总结",detailText:"\n                <h1>资源请求优化: </h1>\n                <h2>1) js css img资源一定要压缩</h2>\n                <h2>2) 能用css做的效果, 不使用js做, 能用原生js做的, 不使用第三方,  避免引入较大第三方库</h2>\n                <h2>3) 图片懒加载, 长页面可以避免未展示的图片提前加载, 较少不必要的请求</h2>\n                <h2>4) 图片使用雪碧图, 把页面上使用的小图标图片整合绘制到一张图片上去, 加载一次就把资源都加载出来了</h2>\n                <h2>5) 一些简单的图片可以使用SVG矢量图, 不变形, 比png渲染快</h2>\n                <h2>6) 避免使用iframe, 之前使用到iframe的情况一般是半弹窗展示协议, 需与后端沟通要返回协议内容, 而不是协议链接</h2>\n                <h2>7) 对于展示类的接口数据, 请求一次后避免每次都需要请求, 拿到数据后下次直接展示就好, 比如点击规则展示</h2>\n                <h2>8) 尽量使用webp图片, webp比同等质量的jpg png都要小25%-35%, 可以有效提升加载性能, 但是会有兼容问题, 要处理好兼容webp</h2>\n                \n                \n                <h1>代码优化:</h1>\n                <h2>1) vue axios vuex jquery zepto等可以通过CDN链接的形式进行加载, 减小代码打包的体积</h2>\n                <h2>2) 节流和防抖操作, 限制方法频繁触发</h2>\n                <h2>3) SPA项目路由页面都进行按需加载</h2>\n                <h2>4) 对于首屏需要请求接口后再展示的页面, 尽量加骨架屏和展示的过渡动画</h2>\n                <h2>5) 去掉prefetch, 虽然prefresh会告诉浏览器加载下一页面会用到的资源, 提前进行加载, 但是会额外浪费用户流量</h2>\n                <h2>6) 图片展示区域, 要设置高度进行占位, 防止图片加载时页面错位的情况</h2>\n                <h2>7) 打包时使用webpack BundleAnalyzerPlugin插件进行观察打包文件的大小, 根据情况进行合理优化</h2>\n                "},{detailId:"article-004",detailTitle:"Jquery组件化写法",detailText:"\n                <h2>\n                    当下前端各种流行框架, Vue React Angular..., 使用这些框架的开发的时候我们都比较喜欢拆出组件, 在需要的地方引入, \n                    不仅方便, 还能提高代码可读性, 降低耦合度, 让项目组件化是这些框架的一个特点, \n                    而原来我们使用jQuery开发的时候, 都是一坨一坨的摞在一起, 那么在jQuery里怎么进行组件化开发呢? \n                </h2>\n\n                <h1>面向对象方式</h1>\n                <h2>\n\n                <h2>\n                "},{detailId:"article-005",detailTitle:"vue-cli3 history模式404解决方案",detailText:"\n                <h1>为何会出现404</h1>\n                <h2>\n                    大家都知道, 单页路由两种模式: history和hash, 我们在实际项目中, 使用history模式时, 都得需要在nginx上进行配置一下, rewrite到index.html上, 否则路由跳转就会出现404, \n                    而使用hash模式就不会出现这类问题, 这是为什么呢? 这是因为hash模式#后面的不被浏览器所识别, 所以当路由无论怎么跳转, 页面是不会按照路由的路径去发起请求的, 而使用了history模式,\n                    路由名是被当做了页面地址的一部分, 浏览器会重新发起请求, 而由于单页面应用只有一个根目录的index.html, 服务器根本没有对应路由名的文件, 所以找不到文件导致了404.\n                </h2>\n                <h1>解决方案</h1>\n                <h2>\n                    一般的解决方案其实就是配置nginx或者索性改成hash模式了, 但是使用nginx相对比较麻烦, 大一点的公司, 有可能权限不在你这, 还得需要找人帮忙配置,\n                    然后能在你这配置, 你得知道怎么配置, 不会就得查喽 哈哈-.- 然后说一下第二种改成hawsh的, 虽然不需要配置了, 但是页面地址看上去怪怪的, 跟锚点一样, \n                    而且当页面使用锚点时,可能还会有冲突, 而且在微信场景里, 貌似是分享之类的可能还有丢失参数的情况(同事遇到过, 本人还没遇到, 所以只能说个大概).\n                </h2>\n                <h2>\n                    然后新的方案就出炉了, 看上面的404的原因大家都知道了, 就是因为路径不是真实的, 找不到文件才404, 那么如果跳转路由时, 对应文件有存在, 那么问题不就解决了嘛\n                    思路就是:\n                    1. 根据路由名, 生成对应的html文件\n                    2. 保证跳转路由的时候能 正确匹配到html文件, 所有路由名字都是 以html结尾\n                </h2>\n                <h2>\n                    上面的思路里路由名字这个比较容易实现, 创建路由的时候都按照html结尾去命名就好了, 但是怎样根据路有名, 生成对应的html文件呢?\n                    可以这样去实现: 每个路由都有对应的 vue文件, 保证这个vue文件的名字前缀与路由名字.html前面的一致, 比如页面名字为abc.vue, 那么路由的名字就是abc.html, \n                    然后在通过node在打包的时候读取存放路由页面文件的文件夹, 得到所有文件名字的数组, 然后把数组里每个文件名的后缀都改成.html, 这样就拿到了所有路由名, \n                    紧接着要用到了webPack的一个插件: HtmlWebpackPlugin, 遍历刚才得到的所有路由名字, 然后使用HtmlWebpackPlugin插件按照每个路由名生成一个html文件, \n                    这样打包出来的时候, 就会每个路由都有对应的html文件, 放到服务器上也能有真是存在文件路径, 完美解决\n                </h2>\n                "},{detailId:"article-009",detailTitle:"滑动尺效果的实现",detailText:"\n                <img src=".concat(n("cc2c"),' />\n                <pre>\n                    <xmp>\n                        <template>\n                            <div>\n                                <div class="result-number">\n                                    <span v-show="!isEdit">{{ count }}</span>\n                                    <input v-show="isEdit" type="number" v-model="inputNumber" @change="handleChange" @keyup.enter="handleChange">\n                                    <span @click="handleEdit">修改</span>\n                                </div>\n                                <div class="scroll-wrapper" ref="scrollWrapper">\n                            \n                                    \x3c!-- 刻度列表 --\x3e\n                                    <div class="ruler-list">\n                            \n                                        \x3c!-- 有效刻度前面的一些无效刻度  用于占位 --\x3e\n                                        <div class="ruler-item" v-for="item in spaceLine" :key="\'before-\'+item">\n                                            <div class="ruler-item-line" ></div>\n                                        </div>\n                            \n                                        \x3c!-- 实际有效刻度 --\x3e\n                                        <div class="ruler-item" v-for="item in dataList" :key="item">\n                                            <div class="ruler-item-line" v-if="item % (itemBoxNumber*10)"></div>\n                                            <div class="ruler-item-number" v-else>\n                                                <div class="ruler-number">\n                                                    {{item}}\n                                                </div>\n                                            </div>\n                                        </div>\n                            \n                                        \x3c!-- 有效刻度后面的一些无效刻度  用于占位 --\x3e\n                                        <div class="ruler-item" v-for="item in spaceLine" :key="\'after-\' +item">\n                                            <div class="ruler-item-line" ></div>\n                                        </div>\n                            \n                                    </div>\n                            \n                                    \x3c!-- 红色指针 --\x3e\n                                    <div class="ruler-point"></div>\n                                </div>\n                            </div>\n                        </template>\n\n                        <script>\n                            import BScroll from "better-scroll";\n                            export default {\n                                props: {\n                                    // 目标刻度值\n                                    targetNumber: {\n                                        type: Number\n                                    },\n                            \n                                    // 刻度尺最大刻度值\n                                    maxNumber: {\n                                        type: Number\n                                    },\n                            \n                                    // 每个格子的颗粒度金额\n                                    itemBoxNumber: {\n                                        type: Number,\n                                        default: 1000\n                                    }\n                                },\n                                data() {\n                                    return {\n                                        isEdit: false,  // 是否为编辑状态\n                                        spaceLine: 16,  // 刻度尺前后空的刻度数 150px/10\n                                        dataList: [],       // 金额列表\n                                        baseNumer: 0,       // 基础金额\n                                        scroolNumber: 0,\n                                        spaceNumber: 0,     // 左边空白的格子对应的金额数  该金额是需要进行删除的部分\n                                        // itemBoxNumber: 1000, // 每个格子的颗粒度金额\n                                        halfContainerWidth: 150, // 半个容器的宽度\n                                        itemBoxhHalfWidth: 4.45, // 每个格子的一半宽度宽度\n                                        baseWidth: 0,               // \n                                        inputNumber: 0\n                                    }\n                                },\n                                computed:{\n                                    count: function() {\n                                        let result = Math.round(this.baseNumer + this.scroolNumber - this.spaceNumber);\n                                        if (result<0) {\n                                            result = 0;\n                                        } else if (result > 300000) {\n                                            result = 300000;\n                                        }\n                                        this.inputNumber = result;\n                                        return result;\n                                    },\n                                },\n                                methods: {\n                            \n                                    /**\n                                     * 初始化尺子\n                                     * targetNumber: 目标值\n                                     * endNumber: 最大刻度值\n                                     * speed: 每个刻度代表金额\n                                     */\n                                    initRuler(targetNumber, endNumber , speed) {\n                                        console.log("---endNumber:", endNumber);\n                                        console.log("---this.maxNumber:", this.maxNumber);\n                                        this.spaceNumber = this.handleConversion(this.spaceLine *10, speed);\n                                        \n                                        this.dataList = [];\n                                        var scaleCount = endNumber/speed;\n                                        for(var i=0; i<=scaleCount; i++) {\n                                            this.dataList.push(i * speed);\n                                        }\n                                        \n                                        this.$nextTick(() => {\n                                            this.baseWidth = this.halfContainerWidth - this.itemBoxhHalfWidth; // 基础宽度 其实就是刻度尺左边到红线指针的距离\n                                            \n                                            // 1. 目标金额-刻度尺起始金额 得到金额差  然后除以系数speed 得到需要移动的格子的数量 然后每个格子的长度是10px  再乘以10\n                                            // 2. 减去红色指针到外层固定宽度容器的距离, 因为移动的距离是从左边算的(不是中间), 所以要把容器的一般宽度去掉\n                                            // 3. 再加上 刻度0前面的无效刻度宽度  无效刻度数为spaceLine 每个刻度是10\n                                            let moveWidth = (targetNumber - this.dataList[0])/speed * 10 - this.baseWidth + this.spaceLine *10; // 需要移动的距离\n                                            \n                                            // 基础金额 相当于是滚动距离为0  但是指针指的为中间金额的刻度 所以要把这段基础距离的基础金额计算出来 后面滚动的时候  再在这基础上进行加减\n                                            this.baseNumer = this.handleConversion(this.baseWidth, speed);\n                                            this.scroolNumber = this.handleConversion(moveWidth, speed);\n                                            this.setBscroll(-moveWidth, speed);\n                                        });\n                                    },\n                                    \n                                    /**\n                                     * 当填写新的目标值的时候调用该方法, 用于计算移动距离 以及移动距离对应的金额\n                                     * 不要再重新初始化刻度尺, 节省性能\n                                     */\n                                    changeRuler(targetNumber, speed) {\n                                        let moveWidth = (targetNumber - this.dataList[0])/speed * 10 - this.baseWidth + this.spaceLine *10; // 需要移动的距离\n                                        console.log("---moveWidth:", moveWidth);\n                                        this.scroolNumber = this.handleConversion(moveWidth, speed);\n                                        console.log("---scroolNumber:", this.scroolNumber);\n                                        this.setBscroll(-moveWidth, speed);\n                                    },\n                            \n                            \n                                    setBscroll(startX, speed) {\n                                        // 判断scroll对象是否被赋值过 赋值过说明已经初始过化了 可直接调用方法移动\n                                        if (!this.scroll) {\n                                            this.scroll = new BScroll(this.$refs.scrollWrapper, {\n                                                startX: startX,\n                                                scrollY: false,\n                                                scrollX: true,\n                                                click: true,\n                                                bounce: false,\n                                                HWCompositing: true,\n                                                probeType: 3,\n                                                mouseWheel: {    // pc端同样能滑动\n                                                    speed: 20,\n                                                    invert: false\n                                                },\n                                                eventPassthrough: "vertical",\n                                                useTransition: false  // 防止iphone微信滑动卡顿\n                                            });\n                                        } else {\n                                            this.scroll.scrollTo(startX, 0, 500);\n                                        }\n                            \n                                        this.scroll.on("scroll", (pos) => {\n                                            this.scroolNumber = this.handleConversion(pos.x + this.itemBoxhHalfWidth, speed);\n                                        });\n                                    },\n                            \n                                    /**\n                                     * 距离换算成金额的处理\n                                     */\n                                    handleConversion(moveX, speed) {\n                                        // 每次移动  先通过移动距离除以每个格子宽度  得到移动的格子数 进行四舍五入 得到整数\n                                        // 然后乘以每个格子的金额  得到移动后的金额数\n                                        return Math.round(Math.abs(moveX/10)) * speed;\n                                    },\n                            \n                            \n                                    handleEdit() {\n                                        this.isEdit = true;\n                                    },\n                            \n                                    /**\n                                     * \n                                     */\n                                    handleChange() {\n                                        this.isEdit = false;\n                                        if (this.inputNumber < 0) {\n                                            this.inputNumber = 0;\n                                            console.log("---金额不能填写小于0");\n                                            // return false;\n                                        } else if (this.inputNumber > 300000) {\n                                            this.inputNumber = 300000;\n                                            console.log("---金额不能超过最大额度: 300000");\n                                            // return false;\n                                        } else if (this.inputNumber%500) {\n                                            this.inputNumber = this.count;\n                                            console.log("---金额必须为500的倍数");\n                                            return false;\n                                        }\n                                        this.changeRuler(parseInt(this.inputNumber, 10), this.itemBoxNumber);\n                                    }\n                            \n                                    \n                                },\n                                mounted() {\n                                    // 入参 1: 指定金额 2, 最大金额 3: 每个格子的颗粒度金额\n                                    this.initRuler(this.targetNumber, this.maxNumber, this.itemBoxNumber);\n                                }\n                            }\n                        <\/script>\n\n                        <style lang="scss">\n                            .result-number {\n                                width: 100%;\n                                text-align: center;\n                                margin-bottom: 30px;\n                            }\n                            \n                            .scroll-wrapper {\n                                margin: 0 auto;\n                                width: 300px;\n                                overflow: hidden;\n                                position: relative;\n                            \n                                .ruler-point {\n                                    position: absolute;\n                                    width: 1px;\n                                    height: 50px;\n                                    background: red;\n                                    top: 0;\n                                    bottom: 0;\n                                    left: 50%;\n                                    margin-left: -0.5px;\n                                }\n                            }\n                            .ruler-list {\n                                display: inline-block;\n                                white-space: nowrap;\n                                height: 50px;\n                            }\n                            \n                            .ruler-item {\n                                display: inline-block;\n                                width: 10px;\n                                height: 20px;\n                                position: relative;\n                            \n                                .ruler-item-line {\n                                    width: 1px;\n                                    height: 10px;\n                                    margin: 1.25px auto;\n                                    background: #666;\n                                }\n                            \n                                .ruler-item-number {\n                                    width: 1px;\n                                    height: 20px;\n                                    margin: 1.25px auto;\n                                    background: #666;\n                                    position: relative;\n                            \n                                    .ruler-number {\n                                        position: absolute;\n                                        bottom: -20px;\n                                        width: 100px;\n                                        left: 50%;\n                                        margin-left: -50px;\n                                        text-align: center;\n                                    }\n                                }\n                            }\n                        </style>\n                    </xmp>\n                </pre>\n                ')},{detailId:"article-011",detailTitle:"npm-check -u 的使用",detailText:"\n                <h1>npm-check简介</h1>\n                <h2></h2>\n                "},{detailId:"article-012",detailTitle:"vue项目跳转外链回退不刷新解决",detailText:'\n                <h1>问题描述: </h1>\n                <h2>\n                    开发项目时, 经常会有使用location.href跳转外部链接的情况, 但是发现一些手机跳转后点击返回, vue的生命周期没有重新执行, \n                    有一些接口数据或者倒计时的操作需要重新开始, 这时候就会存在问题\n                </h2>\n                <h1>解决方案</h1>\n                <h2>\n                    通过网上翻阅各路大神的办法, 都是通过监听 pageshow 方法, 然后执行页面的reload来实现, \n                    大体方案有了, 但是有时候没必要reload页面, 这样页面可能会显得比较怪异, 表现上就是: 加载完页面后刷新了一下又重新加载了一下\n                </h2>\n                <h2>\n                    集合这种方案, 对于一些数据要重新加载的, 可以改为重新调用一下初始化的方法去获取数据, 这样页面就不用再加载一遍\n                </h2>\n\n                <h2>\n                    然后因为不是全部都不执行生命周期, 是在部分手机上会存在, 所以要对这样方案进行差异化设置, \n                    需要的再去再次获取数据, 执行了生命周期的就没必要再去获取数据了, \n                </h2>\n                <h2>总体代码如下:</h2>\n                <pre>\n                    mounted() {\n                        try {\n                            sessionStorage.setItem("loadPage", "1"); // 每次执行mounted都对\'loadPage\'进行重新赋值为1\n                        } catch (error) {\n                            console.log("---error:", error);\n                        }\n                        \n                        this.pageInit();  // 正常情况 执行了mounted生命周期的调用初始化方法\n                \n                        // 绑定pageshow\n                        window.addEventListener("pageshow", () => {\n                            try {\n                                let loadPage = sessionStorage.getItem("loadPage");\n                                if (loadPage != "1") { // 如果loadPage值不为1, 代表重新进入页面没有执行mounted重置loadPage变量为1的操作\n                                    this.pageInit();\n                                }\n                                sessionStorage.setItem("loadPage", "2"); // 每次执行pageshow都对\'loadPage\'进行重新赋值为2\n                            } catch (error) {\n                                console.log("---error:", error);\n                            }\n                        });\n                    }\n                </pre>\n                '},{detailId:"article-016",detailTitle:"前端启动本地服务进行调试",detailText:"\n                <h2>\n                    1. node内置模块http, http.createServer\n                </h2>\n                <h2>\n                    2. 启动一个tomcat\n                </h2>\n                <h2>\n                    3. 安装php-study\n                </h2>\n                <h2>\n                    4. express或者koa2\n                </h2>\n                <h2>\n                    5. 最简单的: http-server\n                </h2>\n                "},{detailId:"article-020",detailTitle:"React setState的回调处理",detailText:"\n                <h2>\n                    正常写法:\n                </h2>\n                <pre>\n                    this.setState({a: 1}, () => {\n                        // next...\n                    });\n                </pre>\n                <h2>\n                    改良写法:\n                </h2>\n                <pre>\n                    public async setState(state) {\n                        return new Promise((resolve) => {\n                            super.setState(state, resolve);\n                        });\n                    }\n\n                    // 在需要的地方直接像下面这么写(注意方法上要加async)\n                    await this.setState({a: 1});\n                    // next...\n                </pre>\n                "},{detailId:"article-022",detailTitle:"console打印增加颜色",detailText:'\n                <h2>\n                    开发过程中, 经常遇到console.log打印一些日志, 在浏览器控制台去查看, 为了区分, 以前经常会通过加一些特殊字符去标识:\n                    console.log("----\x3eaaa")\n                    但是还是不够醒目, 后来发现引的一些插件之类的会打印出特殊颜色的日志, 就搜了一下, 发现给日志加颜色如此简单:\n                    console.log("%c 我是带颜色的日志 啦啦啦~", "color: #f00");\n                    甚至可以加背景色:\n                    console.log("%c 我是有背景色的日志 啦啦啦~", "background:#0f0");\n\n                    不是什么高深技术, 只是之前没有注意到, 记录下来, 在日常开发中可以通过设置console的样式, 有效的区分不同流程 页面 模块的日志, 也更方便\n                    在日志堆里发现自己想要的\n                </h2>\n                <img src='.concat(n("a3eb")," />\n                ")}],seriesList:[{id:"series-001",seriesTitle:"D3.js学习篇",seriesImg:n("1b0f"),catalogList:[{catalogId:"catalogId_001",catalogName:"准备工作"},{catalogId:"catalogId_002",catalogName:"svg学习"}]},{id:"series-002",seriesTitle:"Flutter学习篇",seriesImg:n("69bb")},{id:"series-003",seriesTitle:"Webpack学习篇",seriesImg:n("e9b9")},{id:"series-004",seriesTitle:"TS学习篇",seriesImg:n("cb95")},{id:"series-004",seriesTitle:"ThreeJS学习篇",seriesImg:n("cb95")}],seriesDetailList:[{detailId:"catalogId_001",detailTitle:"CDN缓存导致的",detailText:"\n                <h1>问题描述: </h1>\n                <h2>\n                    每当迭代发布生产时, 都会遇到一个比较头疼的问题, 就是CDN缓存. \n                    html生效了, 但是引用的js css静态资源有的生效有的还是缓存的, 就会导致页面出现异常.\n                    比如使用vue打包出来的项目, 目录里一般是包含: html css js img这些资源, \n                    如果两个\n                </h2>\n                <h1>解决方案</h1>\n                <h2>\n                    1. 每次打包的时候, 生成带有hash的文件名, 这种也是最常用的方式, 打包好后扔到服务器上, 原来的文件不要动, \n                    每次发布的版本都会在上面保留, 这样当html在加载资源时候, 如果html缓存没有更新, 就会加载原来hash的资源文件, \n                    请求时正常的, 如果html缓存更新了, 会加载新发布的hash的资源文件, 这个不会有缓存问题, 也能正常加载, 可以解决问题. \n                    但是有一个弊病就是, 当迭代的多了, 文件较多, 服务器上分不清哪个是上次的 上上次的 ..., 当分件过多想删除的时, \n                    需要一个一个的去识别, 并且还要css js都能匹配删除, 如果不小心删除错了, css和js对不上, 那就出问题了, \n                    还有就是多台机器发布, 有的发布完成, 有的没有完成, 就会出现有的能加载有的不能加载 \n                </h2>\n                <h2>\n                    2. 每次打包的时候, 在文件后面拼接?v=xxx的版本号\n                </h2>\n\n                <h2>\n                    3. 每次打包的时候, 把所有的静态资源不要放到dist的根路径, 每次都创建一个带唯一版本号的文件夹, \n                    然后把资源打包到这个文件夹下, 这样就类似于第一种解决办法一样, 不管是加载新的还是老的资源其实是都在的, \n                    而且能够保证css js是配套加载的, 当文件过多想删除的时候, 可以按照文件夹去删除, 也不会出现方案1的弊病问题.(推荐)\n                </h2>\n                "}]},mutations:{},actions:{}}),q=n("5c96"),H=n.n(q);n("0fae");i["default"].use(H.a),i["default"].config.productionTip=!1,new i["default"]({router:$,store:A,render:function(e){return e(w)}}).$mount("#app")},5722:function(e,t,n){e.exports=n.p+"img/touch.jpg"},"5c0b":function(e,t,n){"use strict";var i=n("e332"),r=n.n(i);r.a},6252:function(e,t,n){"use strict";var i=n("505b"),r=n.n(i);r.a},"69bb":function(e,t,n){e.exports=n.p+"img/flutter.jpg"},7402:function(e,t,n){e.exports=n.p+"img/bibao.jpg"},"75c1":function(e,t,n){e.exports=n.p+"img/quick.jpg"},"764e":function(e,t,n){"use strict";var i=n("8c09"),r=n.n(i);r.a},"8c09":function(e,t,n){},"8d02":function(e,t,n){},a3eb:function(e,t,n){e.exports=n.p+"img/log-color.png"},a8f0:function(e,t,n){e.exports=n.p+"img/404.jpg"},af95:function(e,t,n){e.exports=n.p+"img/gujiaping.jpg"},b0e3:function(e,t,n){e.exports=n.p+"img/ymhd.jpg"},cb95:function(e,t,n){e.exports=n.p+"img/ts.jpg"},cc2c:function(e,t,n){e.exports=n.p+"img/ruler.gif"},e0fc:function(e,t,n){e.exports=n.p+"img/ruler.jpg"},e332:function(e,t,n){},e9b9:function(e,t,n){e.exports=n.p+"img/webpack.jpg"},edc4:function(e,t,n){"use strict";var i=n("8d02"),r=n.n(i);r.a},f638:function(e,t,n){e.exports=n.p+"img/class.jpg"}});